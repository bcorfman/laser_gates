# This workflow will install Python dependencies and build executables with Nuitka
# It builds on Linux and Windows, stores each build as an artifact, creates a Release,
# then uploads each artifact to that Release with a per-asset label.
name: Build Application

on:
  push:
    tags:
      - "v[0-9]+.*"

permissions:
  contents: write

env:
  GITHUB_TOKEN: ${{ github.token }}
  APP_NAME: "lasergates"

jobs:
  build:
    runs-on: ${{ matrix.os }}
    strategy:
      matrix:
        include:
          - os: ubuntu-22.04
            platform: linux
            python-version: "3.11"
          - os: windows-latest
            platform: windows
            python-version: "3.11"

    steps:
      - name: Check out repository
        uses: actions/checkout@v4

      - name: Set up Python ${{ matrix.python-version }}
        uses: actions/setup-python@v5
        with:
          python-version: ${{ matrix.python-version }}
          cache: 'pip'
          cache-dependency-path: |
            **/requirements*.txt

      - uses: seanmiddleditch/gha-setup-vsdevenv@master
        if: matrix.os == 'windows-latest'

      - uses: Chocobo1/setup-ccache-action@v1

      - name: Set env repo name
        run: echo "REPOSITORY_NAME=${GITHUB_REPOSITORY#*/}" >> $GITHUB_ENV
        shell: bash

      - name: Install Dependencies
        run: |
          pip install -r requirements.txt

      - name: Capture lib-dynload directory path (Linux)
        if: matrix.os == 'ubuntu-22.04'
        id: dynload_path
        run: |
          python -c "import os, pathlib, sysconfig, sys; path = pathlib.Path(sysconfig.get_path('stdlib')).resolve() / 'lib-dynload'; open(os.environ['GITHUB_OUTPUT'], 'a', encoding='utf-8').write(f'lib_dynload_dir={path}\n') if path.is_dir() else sys.exit(f'lib-dynload directory not found: {path}')"

      - name: Build Executable with Nuitka (Ubuntu)
        if: matrix.os == 'ubuntu-22.04'
        uses: Nuitka/Nuitka-Action@main
        with:
          nuitka-version: main
          script-name: game.py
          mode: standalone
          output-file: lasergates
          static-libpython: "yes"
          nofollow-import-to: "*tk*,multiprocessing,gi"
          include-package: actions
          disable-plugins: tk-inter,dill-compat,eventlet,gevent,pyqt5,pyqt6,pyside2,pyside6,delvewheel,pywebview,matplotlib,spacy,enum-compat,pbr-compat,gevent,pmw-freezer,transformers,upx,kivy,options-nanny,multiprocessing,gi
          include-data-dir: |
            res=res
            ${{ steps.dynload_path.outputs.lib_dynload_dir }}=.

      - name: Build Executable with Nuitka (Windows)
        if: matrix.os == 'windows-latest'
        uses: Nuitka/Nuitka-Action@main
        with:
          nuitka-version: main
          script-name: game.py
          mode: standalone
          output-file: lasergates
          nofollow-import-to: "*tk*,multiprocessing,gi"
          disable-plugins: tk-inter,dill-compat,eventlet,gevent,pyqt5,pyqt6,pyside2,pyside6,delvewheel,pywebview,matplotlib,spacy,enum-compat,pbr-compat,gevent,pmw-freezer,transformers,upx,kivy,options-nanny,multiprocessing,gi
          include-data-dir: res=res
          include-package: actions
          include-module: unicodedata
          windows-console-mode: force

      - name: Zip Build Output (Linux)
        if: matrix.os == 'ubuntu-22.04'
        run: |
          set -euo pipefail
          echo "Searching for built Linux binary directory..."
          # List to help debugging when paths change (disable pipefail temporarily)
          set +o pipefail
          ls -laR . | head -n 500 || true
          set -o pipefail
          BIN_DIR=$(find . -type d -name 'game.dist' | head -n1)
          if [ -z "${BIN_DIR}" ]; then
            echo "ERROR: No Linux dist directory found after build"
            echo "Searching for all .dist directories..."
            find . -type d -name '*.dist' | head -n 5
            exit 1
          fi
          echo "Found: ${BIN_DIR}"
          mkdir -p zip_output
          cd "${BIN_DIR}"
          zip -r "../../zip_output/lasergates-linux.zip" .
          cd -
        shell: bash

      - name: Zip Build Output (Windows)
        if: matrix.os == 'windows-latest'
        run: |
          Write-Host "Searching for built Windows binary directory..."
          $DistDir = Get-ChildItem -Recurse -Directory -Filter 'game.dist' | Select-Object -First 1
          if ($null -eq $DistDir) {
            Write-Error "ERROR: No Windows dist directory found after build"
            Write-Host "Searching for all .dist directories..."
            Get-ChildItem -Recurse -Directory -Filter '*.dist' | Select-Object -First 5 | ForEach-Object { Write-Host $_.FullName }
            exit 1
          }
          Write-Host ("Found: " + $DistDir.FullName)
          New-Item -ItemType Directory -Force -Path zip_output | Out-Null
          Compress-Archive -Path "$($DistDir.FullName)\*" -DestinationPath "zip_output\lasergates-windows.zip" -Force
        shell: pwsh

      - name: Upload build artifact
        uses: actions/upload-artifact@v4
        with:
          name: ${{ matrix.platform }}
          path: zip_output/lasergates-${{ matrix.platform }}.zip

  release:
    runs-on: ubuntu-latest
    needs: build
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Download All Build Artifacts
        uses: actions/download-artifact@v4
        with:
          path: downloads

      - name: Create release (if missing) and upload artifacts to tag
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          set -euo pipefail
          TAG="${{ github.ref_name }}"
          echo "Target release tag: $TAG"
          if gh release view "$TAG" >/dev/null 2>&1; then
            echo "Release $TAG already exists; will upload assets with --clobber"
          else
            gh release create "$TAG" \
              --title "$TAG" \
              --notes "Automated build for $TAG"
          fi
          gh release upload "$TAG" downloads/**/*.zip --clobber