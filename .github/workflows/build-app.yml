# This workflow will install Python dependencies and build executables with Nuitka
# It builds on Linux and Windows, stores each build as an artifact, creates a Release,
# then uploads each artifact to that Release with a per-asset label.
name: Build Application

on:
  push:
    tags:
      - "v[0-9]+.*"

permissions:
  contents: write

env:
  GITHUB_TOKEN: ${{ github.token }}
  APP_NAME: "lasergates"

jobs:
  build:
    runs-on: ${{ matrix.os }}
    strategy:
      matrix:
        include:
          - os: ubuntu-22.04
            platform: linux
            python-version: "3.11"
          - os: windows-latest
            platform: windows
            python-version: "3.11"

    steps:
      - name: Check out repository
        uses: actions/checkout@v5

      - name: Set up Python ${{ matrix.python-version }}
        uses: actions/setup-python@v5
        with:
          python-version: ${{ matrix.python-version }}
          architecture: "x64"
          cache: "pip"
          cache-dependency-path: |
            **/pyproject.toml

      - uses: seanmiddleditch/gha-setup-vsdevenv@master
        if: matrix.os == 'windows-latest'

      - name: Install Dependencies
        run: |
          pip install .

      - name: Build Executable with Nuitka (Linux)
        uses: Nuitka/Nuitka-Action@main
        if: matrix.os == 'ubuntu-22.04'
        with:
          nuitka-version: main
          script-name: game.pyw
          mode: standalone
          nofollow-import-to: "*tk*,_codecs,encodings,multiprocessing,gi"
          disable-plugins: tk-inter,dill-compat,eventlet,gevent,pyqt5,pyqt6,pyside2,pyside6,delvewheel,pywebview,matplotlib,spacy,enum-compat,pbr-compat,gevent,pmw-freezer,transformers,upx,kivy,options-nanny,multiprocessing,gi
          include-data-dir: res=res
          output-file: lasergates

      - name: Create AppImage (Linux)
        if: matrix.os == 'ubuntu-22.04'
        run: |
          set -euo pipefail
          
          # Download appimagetool
          wget -q https://github.com/AppImage/AppImageKit/releases/download/continuous/appimagetool-x86_64.AppImage -O appimagetool
          chmod +x appimagetool
          
          # Extract appimagetool (GitHub Actions doesn't have FUSE)
          ./appimagetool --appimage-extract
          
          # Find the standalone directory (Nuitka creates game.dist based on script name)
          STANDALONE_DIR=$(find . -type d \( -name "game.dist" -o -name "game.build" \) | head -n1)
          if [ -z "${STANDALONE_DIR}" ]; then
            echo "ERROR: Could not find standalone directory"
            echo "Searching for all .dist directories..."
            find . -type d -name "*.dist" | head -10
            exit 1
          fi
          
          echo "Found standalone directory: ${STANDALONE_DIR}"
          
          # Create AppDir structure
          mkdir -p laser_gates.AppDir/usr/bin
          cp -r "${STANDALONE_DIR}"/* laser_gates.AppDir/usr/bin/
          
          # Find the executable
          EXECUTABLE=$(find laser_gates.AppDir/usr/bin -type f -name "lasergates" -perm -u+x | head -n1)
          if [ -z "${EXECUTABLE}" ]; then
            echo "ERROR: Could not find lasergates executable"
            ls -la laser_gates.AppDir/usr/bin/ | head -20
            exit 1
          fi
          
          # Create desktop file
          mkdir -p laser_gates.AppDir
          cat > laser_gates.AppDir/laser_gates.desktop <<EOF
          [Desktop Entry]
          Type=Application
          Name=Laser Gates
          Exec=lasergates
          Icon=laser_gates
          Categories=Game;
          Terminal=false
          EOF
          
          # Create AppRun script
          cat > laser_gates.AppDir/AppRun <<EOF
          #!/bin/sh
          HERE=\$(dirname \$(readlink -f "\${0}"))
          exec "\${HERE}/usr/bin/lasergates" "\$@"
          EOF
          chmod +x laser_gates.AppDir/AppRun
          
          # Create AppImage using extracted appimagetool
          ARCH=x86_64 ./squashfs-root/AppRun laser_gates.AppDir laser_gates.AppImage
          
          # Verify AppImage was created
          if [ ! -f laser_gates.AppImage ]; then
            echo "ERROR: AppImage creation failed"
            exit 1
          fi
          
          # Make it executable
          chmod +x laser_gates.AppImage
          
          # Create output directory
          mkdir -p build_output
          cp laser_gates.AppImage build_output/laser_gates.AppImage
          echo "AppImage created: build_output/laser_gates.AppImage"
        shell: bash

      - name: Build Executable with Nuitka (Windows)
        uses: Nuitka/Nuitka-Action@main
        if: matrix.os == 'windows-latest'
        with:
          nuitka-version: main
          script-name: game.pyw
          mode: onefile
          nofollow-import-to: "*tk*,_codecs,encodings,multiprocessing,gi"
          disable-plugins: tk-inter,dill-compat,eventlet,gevent,pyqt5,pyqt6,pyside2,pyside6,delvewheel,pywebview,matplotlib,spacy,enum-compat,pbr-compat,gevent,pmw-freezer,transformers,upx,kivy,options-nanny,multiprocessing,gi
          include-data-dir: res=res
          output-file: lasergates
          windows-console-mode: disable

      - name: Verify AppImage (Linux)
        if: matrix.os == 'ubuntu-22.04'
        run: |
          set -euo pipefail
          if [ ! -f build_output/laser_gates.AppImage ]; then
            echo "ERROR: AppImage not found at build_output/laser_gates.AppImage"
            ls -la build_output/ || true
            exit 1
          fi
          echo "AppImage verified: build_output/laser_gates.AppImage"
          ls -lh build_output/laser_gates.AppImage
        shell: bash

      - name: Locate and rename executable (Windows)
        if: matrix.os == 'windows-latest'
        run: |
          Write-Host "Searching for built Windows binary..."
          Get-ChildItem -Recurse -File -Filter 'lasergates*.exe' | Select-Object -First 1 | ForEach-Object {
            Write-Host ("Found: " + $_.FullName)
            New-Item -ItemType Directory -Force -Path build_output | Out-Null
            Copy-Item $_.FullName "build_output\laser_gates.exe"
            Write-Host "Executable ready: build_output\laser_gates.exe"
          }
          if (!(Test-Path build_output\laser_gates.exe)) {
            Write-Error "ERROR: No Windows binary found after build"
            exit 1
          }
        shell: pwsh

      - name: Upload build artifact
        uses: actions/upload-artifact@v5
        with:
          name: ${{ matrix.platform }}
          path: build_output/laser_gates.*

  release:
    runs-on: ubuntu-latest
    needs: build
    steps:
      - name: Checkout repository
        uses: actions/checkout@v5
        with:
          fetch-depth: 0

      - name: Download All Build Artifacts
        uses: actions/download-artifact@v6
        with:
          path: downloads

      - name: Create release (if missing) and upload artifacts to tag
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
        run: |
          set -euo pipefail
          TAG="${{ github.ref_name }}"
          echo "Target release tag: $TAG"
          if gh release view "$TAG" >/dev/null 2>&1; then
            echo "Release $TAG already exists; will upload assets with --clobber"
          else
            gh release create "$TAG" \
              --title "$TAG" \
              --notes "Automated build for $TAG"
          fi
          # Upload the executables directly (no zip files)
          gh release upload "$TAG" downloads/linux/laser_gates.AppImage --clobber
          gh release upload "$TAG" downloads/windows/laser_gates.exe --clobber